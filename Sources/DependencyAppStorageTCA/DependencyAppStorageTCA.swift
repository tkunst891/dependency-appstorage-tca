import _AppStorageDependency
import ComposableArchitecture

extension Dependency.AppStorage.Values {
    
    /// Create a long-living `Effect` (`.run`), which observes changes to the @Dependency.AppStorage variable
    /// and forwards this change to a reducerÂ´s `State`.
    ///
    /// **Note**: The current value of the AppStorage variable
    /// (which is the first element of the AsyncSequence created as projected value of the AppStorage property wrapper)
    /// will not be forwarded to the state, as the state is assumed to be  already initialized with the current value.
    /// - Parameter keyPath: KeyPath to the member of the `State` whose value will be set.
    ///     This must  be wrapped with a `@BindableState` property wrapper, and referenced with its projected value (`\.$member`)
    /// - Returns: A long-lived `Effect` which will send a `.binding(.set(keyPath, <newValue>))` action
    ///     every time that the AppStorage variable changes.
    public func bind<Action>(to keyPath: WritableKeyPath<Action.State, BindingState<Value>>) -> Effect<Action>
    where Action: BindableAction, Value: Equatable {
        return .run { send in
            for await value in self.dropFirst() {
                await send(Action.set(keyPath, value))
            }
        }
    }
}

/// Protocol to be implemented by a class which contains your application's settings as @Dependency.AppStorage values.
///
/// Let a class implement this protocol to build a singleton object which contains all your AppStorage values:
/// ```swift
/// final class MySettings: DependencySettings {
///     @Dependency.AppStorage("username") var username: String?
///     @Dependency.AppStorage("isSoundEnabled") var isSoundEnabled: Bool = false
/// }
/// ```
/// - Note: You should never create instances of this class yourself. Instead, a ``DependencySettings/shared-6557t``
///     instance of this class is automatically generated by the default implementation of the protocol, which lets you access the values:
/// ```swift
/// if MySettings.shared.isSoundEnabled {
///    ...
/// }
/// ```
public protocol DependencySettings: AnyObject {
    /// The shared singleton instance which is automatically generated by the default implementation of this protocol.
    static var shared: Self { get }
    /// The class implementing this protocol must have a default initializer,
    /// but it should never be called directly. Only use the `shared` instance.
    ///
    /// You do not need to explicitely declare the `init()` method.
    /// The class should only contain `@Dependency.AppStorage` values, which are automatically initialized.
    /// The compiler will then generate the `init()` method.
    init()
    
    /// Create an Effect which sets a value to one of the members of the class asynchronously.
    /// - Parameters:
    ///   - keyPath: Identifies the class' member (a @Dependency.AppStorage variable) which shall be set.
    ///   - value: The value that shall be set. Its type must match the type of the class member to which the keyPath points.
    /// - Returns: An `Effect` which can be returned as result of a `Reducer`'s `reduce` method. Executing the effect should set the value of the AppStorage variable. That is what the default implementation does.
    func set<Value, Action>(_ keyPath: ReferenceWritableKeyPath<Self, Value>, to value: Value) -> Effect<Action>
}

/// Default implementations of the `shared` instance and the `set` method.
extension DependencySettings {
    public static var shared: Self {
        .init()
    }
    public func set<Value, Action>(_ keyPath: ReferenceWritableKeyPath<Self, Value>, to value: Value) -> Effect<Action> {
        return .fireAndForget { () async in
            self[keyPath: keyPath] = value
        }
    }
}

extension BindingReducer {
    /// Create a higher-level reducer which executes the BindingReducer and then sets an `AppStorage` value in your shared ``DependencySettings`` object.
    ///
    /// The higher-level reducer will test whether the action is a `.binding` action matching the `from:` KeyPath.
    /// If so, this indicates that the corresponding State value has just been set by the BindingReducer.
    /// In this case the `to:` member of the ``DependencySettings`` object will be set to the same value (taken from the State).
    /// Setting the value will be accomplished via the ``DependencySettings/set(_:to:)-4i94o`` method of the ``DependencySettings`` object.
    /// - Parameters:
    ///   - state: Keypath to the state's member whose value should be copied to AppStorage. Must be a KeyPath to a `BindableState` (use `\.$member`)
    ///   - appStorage: Keypath to a member of a class conforming to the ``DependencySettings`` protocol. This member will be set to the same value as the state.
    /// - Returns: A reducer which first executes the base reducer and then issues a `.fireAndForget` Effect which will asynchronously set the `@Dependency.AppStorage` value.
    public func toAppStorage<Settings: DependencySettings, Value>(
        state: KeyPath<Self.State, BindingState<Value>>,
        appStorage: ReferenceWritableKeyPath<Settings, Value>
    ) -> _AppStorageReducer<Self, Settings, Value> {
        .init(parent: self, fromState: state, toAppStorage: appStorage)
    }
}

public struct _AppStorageReducer<Parent: Reducer, Settings: DependencySettings, Value>: Reducer
where Parent.Action: BindableAction, Parent.State == Parent.Action.State {
    let parent: Parent
    let fromState: KeyPath<State, BindingState<Value>>
    let toAppStorage: ReferenceWritableKeyPath<Settings, Value>

    public func reduce(into state: inout Parent.State, action: Parent.Action) -> Effect<Parent.Action> {
        var result = self.parent.reduce(into: &state, action: action)
        if let bindingAction = (/Action.binding).extract(from: action), bindingAction.keyPath == fromState {
            result = result.concatenate(
                with: Settings.shared.set(toAppStorage, to: state[keyPath: fromState].wrappedValue)
            )
        }
        return result
    }
}

extension _AppStorageReducer {
    /// Create a higher-level reducer which executes the BindingReducer and then sets an `AppStorage` value in your shared ``DependencySettings`` object.
    ///
    /// The higher-level reducer will test whether the action is a `.binding` action matching the `from:` KeyPath.
    /// If so, this indicates that the corresponding State value has just been set by the BindingReducer.
    /// In this case the `to:` member of the ``DependencySettings`` object will be set to the same value (taken from the State).
    /// Setting the value will be accomplished via the ``DependencySettings/set(_:to:)-4i94o`` method of the ``DependencySettings`` object.
    /// - Parameters:
    ///   - state: Keypath to the state's member whose value should be copied to AppStorage. Must be a KeyPath to a `BindableState` (use `\.$member`)
    ///   - appStorage: Keypath to a member of a class conforming to the ``DependencySettings`` protocol. This member will be set to the same value as the state.
    /// - Returns: A reducer which first executes the base reducer and then issues a `.fireAndForget` Effect which will asynchronously set the `@Dependency.AppStorage` value.
    public func toAppStorage<Settings: DependencySettings, NextValue>(
        state: KeyPath<Self.State, BindingState<NextValue>>,
        appStorage: ReferenceWritableKeyPath<Settings, NextValue>
    ) -> _AppStorageReducer<Self, Settings, NextValue> {
        .init(parent: self, fromState: state, toAppStorage: appStorage)
    }
}
